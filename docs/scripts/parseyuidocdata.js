(function(module) {
  var _ = require('underscore');
  var fs = require('fs');
  var createNamespaceTree = require('./createnamespacetree');
  var isCalledFromCommandLine = (require.main === module);

  var missingItems = [];


  /**
   * Parses view data generated by YUIDoc.
   * Moves all classitems into their class objects.
   * Nests namespaces.
   *
   * Eg:
   *  {
   *    "animals": {
   *      classes: [
   *        {
   *          name: "AnimalInterface",
   *          method: [
   *            { name: 'speak', ... }
   *          ],
   *          property: [
   *            { name: 'color', ... }
   *          ]
   *        }
   *      ],
   *      namespaces: {
   *        birds: {
   *          classes: [...]
   *          namespaces: {...}
   *        },
   *        fish: { ... }
   *      }
   *    }
   *  }
   *
   * Command line usage:
   *  $ node parseyuidocdata.js YUIDocViewData.json parsedDataOutput.json
   *
   * @param {Object} data
   * @returns {Object}
   */
  var parseYuiDocData = function(data) {
    var nsTree, nsTreePublic, classesPublic;

    processClasses(data.classes, data.classitems);
    classesPublic = createPublicApiClasses(data.classes);

    nsTree = createNamespaceTree(_.values(data.classes));
    nsTreePublic = createNamespaceTree(_.values(classesPublic));


    return {
      classes: data.classes,
      namespaces: nsTree,
      publicApi: {
        classes: classesPublic,
        namespaces: nsTreePublic
      },
      missingItems: missingItems
    };
  };


  function processClasses(classes, classItems) {
    _.each(classes, fixItemLineEndings);
    addItemsToClasses(classes, classItems);
    addParentRefsToClasses(classes);
    extendClassesWithParentItems(classes);
  }

  function addItemsToClasses(classes, classItems) {
    var typeMap = {
      method: 'methods',
      property: 'properties',
      attribute: 'attributes',
      event: 'events'
    };

    _.each(classItems, function(item) {
      var classObj = classes[item.class];
      var isItemTypeUndefined = !!!item.itemtype;     // For whatever reason, !item.itemType does not work.
      var itemType = isItemTypeUndefined ? 'other': typeMap[item.itemtype];

      if (!classObj) { return; }

      fixItemLineEndings(item);

      // Store a list of items without proper annotations
      // for debugging purposes
      if (isItemTypeUndefined) {
        missingItems.push(item);
      }


      classObj[itemType] || (classObj[itemType] = {});
      classObj[itemType][item.name] = item;
    });
  }

  function fixItemLineEndings(item) {
    if (item.name) {
      item.name = item.name.replace('!~YUIDOC_LINE~!', '');
    }
    if (item.params) {
      item.params = item.params.map(function(param) {
        param.name = param.name.replace('!~YUIDOC_LINE~!', '');
        return param;
      });
    }
  }

  function addParentRefsToClasses(classes) {
    _.each(classes, function(classObj) {
      classObj.parent = classes[classObj.extends];
      classObj.mixesRef = classes[classObj.mixes];
    });
  }

  function extendClassesWithParentItems(classes) {
    _.each(classes, addParentItems);

    function addParentItems(classObj) {
      var child = classObj;
      _.defaults(classObj, {
        methods: {},
        properties: {},
        events: {},
        attributes: {},
        other: {},
        params: []
      });

      while (child) {
        var parent = child.parent;

        if (!_.isUndefined(child.parent)) {
          extendClass(classObj, parent);
        }

        if (!_.isUndefined(child.mixesRef)) {
          extendClass(classObj, child.mixesRef);
        }
        if (!_.isUndefined(child.implements)) {
          var implementsRef = classes[child.implements];

          if (!_.isUndefined(implementsRef)) {
            extendClass(classObj, implementsRef);
          }
          else {
            console.warn('Unable to find class ' + child.implements + 'implemented by ' + child.name);
          }

        }

        child = parent;
      }
    }

  }

  function extendClass(child, parent) {
    var types = ['methods', 'properties', 'events', 'attributes', 'other'];

    _.each(types, function(itemType) {
      var parentItems = parent[itemType];
      var childItems = child[itemType];

      // Prefer parent type docs,
      // unless @override is used on child
      _.each(parentItems, function(parentItem, itemName) {
        var childItem = childItems[itemName];
        var childOverridesDocs = childItem && !_.isUndefined(childItem.override);
        var isItemStatic = !!parentItem.static;

        if (!childOverridesDocs && !isItemStatic) {
          childItems[itemName] = parentItems[itemName]
        }
      });

      // Extend ctor params
      if (parent.params) {
        parent.params.forEach(function(param, i) {
          var doesChildHaveParam = _.findWhere(child.params, { name: param.name });

          if (!doesChildHaveParam) {
            child.params.splice(i, 0, param);
          }
        });
      }
    });
  }


  function createPublicApiClasses(classes) {
    var publicClasses = {};
    classes = _.clone(classes);

    _.each(classes, function(classObj, className) {
      classObj = _.clone(classObj);

      // Filter out private items
      _.each(['methods', 'properties', 'events', 'attributes', 'other'], function(itemType) {
        if (!classObj[itemType]) { return; }

        classObj[itemType] = _.clone(classObj[itemType]);

        _.each(classObj[itemType], function(item, itemName) {
          var isPublicItem = (item.access !== 'private') && (item.access !== 'protected');

          if (!isPublicItem) {
            delete classObj[itemType][itemName];
          }
        });
      });


      // Filter for @publicApi annotated classes
      if (classObj.hasOwnProperty('publicapi')) {
        publicClasses[className] = classObj;
      }
    });

    return publicClasses;
  }



  function getFileFromArg(argIndex, errMsg) {
    if (!process.argv[argIndex]) {
      console.log(errMsg);
      process.exit(1);
    }

    return process.cwd() + '/' + process.argv[argIndex];
  }



  if (isCalledFromCommandLine) {
    var dataFile = getFileFromArg(2, 'Must specify a data file');
    var outFile = getFileFromArg(3, 'Must specify an output file');
    var data = JSON.parse(fs.readFileSync(dataFile, 'utf8'));

    var parsedData = parseYuiDocData(data);

    fs.writeFileSync(outFile, JSON.stringify(parsedData, null, 2));

    console.log('Done!');
    process.exit(0);
  }
  else {
    module.exports = parseYuiDocData;
  }
}(module));